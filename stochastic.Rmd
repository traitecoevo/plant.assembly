---
title: "Stochastic assembly"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{stochastic_assembly}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette provides an example of running a stocahstic assembly use plant.assembly. Below we consider both a 1 and 2 trait example.

First, basic setup:

```{r, setup}
library(plant)
library(plant.assembly)

library(tidyverse)
library(ggplot2)

# devtools::load_all()
#devtools::load_all("../plant-dev")

# logging of output
plant_log_console()

# set controls on plant package 
plant_control <- function() {
  ctrl <- scm_base_control()
  ctrl$equilibrium_nsteps <- 80
  ctrl$equilibrium_solver_name <- "iteration"
  ctrl
}

# set baseline parameters
p <- scm_base_parameters("FF16")
p$strategy_default$a_l1 <- 2.17
p$strategy_default$a_l2 <- 0.5
p$max_patch_lifetime <- 60

```

# One trait: lma

Now let's run the assembly for a single trait

## Assembly

```{r}
# Set absolute bounds
bounds0 <- bounds(lma = c(0.01, 1))

# set controls on assembly
control <- assembler_control(
  list(
    run_type = "single",
    birth_type = "stochastic",
    vcv = diag(1)
  )
)

# setup the assembler to start with empty community
community0 <- community_start(p, bounds0)
obj <- assembler_start(community0, control = control)

# run assembler
obj <- assembler_run(obj, nsteps = 100)

saveRDS(obj, "output/stochastic.rds")
```

## Analysis

```{r}
obj <- readRDS("output/stochastic.rds")
```

The evolutionary trajectory of different trait values as they are added to the community can be plotted. Red plots are traits that are added to the community in a given step, whereas black points are traits which have persisted even after new trait values have been added. 

```{r}
trait_history <- list()
birth_history <- list()

birth_history <- map(obj$history, ~.x$birth_rate)

for(i in 1:length(obj$history)){
  
  if(length(obj$history[[i]]$traits) == 0){
    trait_history[[i]] <- obj$history[[i]]$traits %>% as_tibble() 
  } else {
    if(i == 1){
    trait_history[[i]] <- obj$history[[i]]$traits %>% as_tibble() %>%
      mutate(invader = "no") %>%
      mutate(step = paste0("Step = ", i))
    }
     if(i > 1){
    trait_history[[i]] <- obj$history[[i]]$traits %>% as_tibble() %>% mutate(invader = map_chr(lma, ~if_else(.x %in% trait_history[[i-1]]$lma, "no", "yes")))%>%
      mutate(step = paste0("Step = ", i))
     }
  }
  }

plot_history_one_trait <- function(trait_history, birth_history){
  myColors <- c("red","black")
  names(myColors) <- c("yes","no")
  colScale <- scale_colour_manual(values = myColors)
  
  if(length(trait_history$lma) == 0){
    p <- NA
    return(p)
  }
  
  plot_data <- tibble(
    traits = trait_history,
    birth_rates = birth_history
  ) %>%
    unnest(traits)
    plot_data %>%
    ggplot(aes(x = lma, y = birth_rates)) + 
    geom_point(aes(colour = invader), size = 2) +
    xlab(history_object$trait_names) +
    ylab("Birth rate") +
    theme_classic() + 
    theme(text = element_text(size = 16),
          legend.position = "none") +
    scale_x_log10(limits = c(0.01, 1)) +
    scale_y_log10(limits = c(0.0001,5)) +
      colScale +
      geom_text(aes(x = 0, y = Inf, label = step, vjust = "inward", hjust = "inward"), size = 5)-> p

  return(p)
}

plots <- map2(trait_history, birth_history, ~plot_history_one_trait(.x,.y))
plots <- plots[map_lgl(plots, ~!is.na(.x[1]))] 
walk2(plots, seq_along(plots), ~ggsave(filename = paste0("output/stochastic_plot_history_one_trait/",.y,".png"), plot = .x))
```

## Fitness landscapes

We might want to caluclate fitness landscape for assembled community

```{r}

```

# Two traits: lma + hmat

Now let's run the assembly for two traits

## Assembly

```{r}

bounds0 <- bounds(lma = c(0.01, 1), hmat = c(0.5, 30))

# controls on assembly
control <- assembler_control(
  list(
    run_type = "single",
    birth_type = "stochastic",
    compute_viable_fitness = FALSE,
    vcv = diag(2)
  )
)

# setup the assembler to start with empty community
community0 <- community_start(p, bounds0)
obj <- assembler_start(community0, control = control)

# run assembly
obj <- assembler_run(obj, nsteps =10)
```

```{r}
saveRDS(obj, "output/stochastic_two_species.rds")
```

## Analysis

Now lets' look at the results

Two-trait species output
```{r}
plot_history_two_traits <- function(two_trait_history_object, step){
  two_trait_history_object$traits %>%
  as_tibble() -> traits
  
  two_trait_history_object$birth_rate %>%
  as_tibble() -> birth_rate
  
  out <- bind_cols(traits, birth_rate) %>%
    mutate(step = paste0("Step = ", step))
  out %>% 
    ggplot(aes(x = lma, y = hmat)) +
    geom_point(aes(colour = value)) +
    theme_classic() +
    scale_x_log10(limits = c(0.01, 1)) +
    scale_y_log10(limits = c(0.5, 30)) +
    scale_color_continuous(trans = "log", limits = c(1e-4, 1e3)) +
    labs(x = "LMA", y = expression(paste(H[mat]))) +
    geom_text(aes(x = 0, y = Inf, label = step, vjust = "inward", hjust = "inward"), size = 5)
}

two_trait_plots <- map2(obj$history, seq_along(obj$history), ~plot_history_two_traits(.x, .y))

walk2(two_trait_plots, seq_along(two_trait_plots), ~ggsave(filename = paste0("output/stochastic_plot_history_two_traits/",.y,".png"), plot = .x))

```

How many species in the community?
```{r}
p$max_patch_lifetime
p$strategy_default$hmat
obj$community$traits
obj$community$birth_rate
```

```{r}
landscape <- obj$community$fitness_approximate_points %>% as_tibble()
ggplot(landscape, aes(lma, fitness)) + 
  geom_line() +
  scale_x_log10() +
  geom_point(data = tibble(lma = obj$community$traits[,1], fitness = 0), col="red")
```

